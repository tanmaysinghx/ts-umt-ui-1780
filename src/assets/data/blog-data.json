[
  {
    "id": 1,
    "title": "The Complete Angular Handbook: Architecture, Hooks, & Patterns",
    "date": "2025-11-29",
    "author": "Tanmay Singh",
    "linkedin": "https://www.linkedin.com/in/tanmaysinghx/",
    "category": "Frontend, Angular, Shortnotes",
    "role": "Software Engineer",
    "excerpt": "A massive deep-dive into the Angular ecosystem. We cover Standalone Components, every Lifecycle Hook, Service Singletons, Functional Guards, Interceptors, Signals, and the new Deferrable Views.",
    "content": [
      {
        "type": "paragraph",
        "text": "Angular has evolved significantly. This guide is designed to be your one-stop reference for building scalable applications in 2024. We will break down the framework into its core pillars."
      },
      {
        "type": "heading",
        "text": "1. Architecture: Standalone Components"
      },
      {
        "type": "paragraph",
        "text": "The fundamental building block. Since Angular 15+, we no longer need 'NgModules'. Components are self-contained."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "@Component({\n  selector: 'app-root',\n  standalone: true,\n  // Import other components, directives, and pipes here\n  imports: [CommonModule, RouterOutlet, UserCardComponent],\n  template: `\n    <header>My App</header>\n    <router-outlet />\n  `\n})\nexport class AppComponent {}"
      },
      {
        "type": "heading",
        "text": "2. Data Flow: Inputs, Outputs, & Signals"
      },
      {
        "type": "paragraph",
        "text": "How do components talk to each other? We used to use @Input decorators, but modern Angular prefers 'Signal Inputs' for better reactivity."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "export class UserCardComponent {\n  // Old Way\n  @Input() legacyName: string = '';\n\n  // New Signal Way (Available in Angular 17.1+)\n  // This creates a read-only signal.\n  userId = input.required<string>();\n  \n  // Output (Event Emitter)\n  @Output() save = new EventEmitter<void>();\n}"
      },
      {
        "type": "heading",
        "text": "3. Component Lifecycle Hooks"
      },
      {
        "type": "paragraph",
        "text": "Understanding *when* things happen is crucial. Here is the chronological order of the most important hooks:"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "export class LifeCycleDemo implements OnInit, OnChanges, AfterViewInit, OnDestroy {\n  \n  // 1. Triggered when @Input values change\n  ngOnChanges(changes: SimpleChanges) {\n    console.log('Inputs changed', changes);\n  }\n\n  // 2. Triggered once after component initialization\n  // BEST PLACE for API calls.\n  ngOnInit() {\n    this.loadData();\n  }\n\n  // 3. Triggered after the HTML template is fully rendered\n  ngAfterViewInit() {\n    // Access DOM elements here (e.g., Canvas, Scroll position)\n  }\n\n  // 4. Triggered just before component is removed\n  // BEST PLACE for cleanup (unsubscribing).\n  ngOnDestroy() {\n    this.stream$.unsubscribe();\n  }\n}"
      },
      {
        "type": "image",
        "url": "https://images.unsplash.com/photo-1504639725590-34d0984388bd?q=80&w=2000&auto=format&fit=crop",
        "caption": "Lifecycle Visualization"
      },
      {
        "type": "heading",
        "text": "4. Services & Dependency Injection"
      },
      {
        "type": "paragraph",
        "text": "Services hold your business logic and state. Angular's DI system is hierarchical. Using `providedIn: 'root'` makes the service a Singleton (one instance for the whole app)."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "@Injectable({ providedIn: 'root' })\nexport class AuthService {\n  // BehaviorSubject holds the current value and emits to new subscribers\n  private currentUser = new BehaviorSubject<User | null>(null);\n  \n  // Expose as Observable (read-only) for components\n  user$ = this.currentUser.asObservable();\n\n  login(credentials: any) {\n    // Logic here...\n  }\n}"
      },
      {
        "type": "heading",
        "text": "5. Modern HTTP Interceptors"
      },
      {
        "type": "paragraph",
        "text": "We no longer use class-based interceptors. We use functional interceptors to modify HTTP requests globally (e.g., adding Auth Tokens)."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "export const authInterceptor: HttpInterceptorFn = (req, next) => {\n  const token = localStorage.getItem('token');\n  \n  if (token) {\n    const cloned = req.clone({\n      setHeaders: { Authorization: `Bearer ${token}` }\n    });\n    return next(cloned);\n  }\n  \n  return next(req);\n};"
      },
      {
        "type": "heading",
        "text": "6. Routing & Functional Guards"
      },
      {
        "type": "paragraph",
        "text": "Protecting routes is essential. Modern Angular uses Functional Guards which are easier to test and compose."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// Route Definition\nexport const routes: Routes = [\n  {\n    path: 'dashboard',\n    loadComponent: () => import('./dashboard.component').then(m => m.DashboardComponent),\n    canActivate: [authGuard]\n  }\n];\n\n// Functional Guard\nexport const authGuard: CanActivateFn = (route, state) => {\n  const authService = inject(AuthService);\n  const router = inject(Router);\n\n  if (authService.isLoggedIn()) {\n    return true;\n  }\n  \n  return router.createUrlTree(['/login']);\n};"
      },
      {
        "type": "heading",
        "text": "7. Advanced Performance: @defer"
      },
      {
        "type": "paragraph",
        "text": "Angular 17 introduced Deferrable Views. This allows you to lazy-load specific chunks of a template (like a heavy chart or comment section) only when they are visible in the viewport."
      },
      {
        "type": "code",
        "language": "html",
        "code": "\n\n@defer (on viewport) {\n  <app-heavy-chart [data]=\"salesData\" />\n} @placeholder {\n  <div class=\"skeleton-loader\">Loading Chart...</div>\n} @loading (minimum 1s) {\n  <span class=\"spinner\"></span>\n}"
      }
    ],
    "image": "https://images.unsplash.com/photo-1550751827-4bd374c3f58b?q=80&w=2000&auto=format&fit=crop"
  },
  {
  "id": 2,
  "title": "Deep Dive: JVM Architecture & String Pool Internals",
  "date": "2024-05-12",
  "author": "Tanmay Singh",
  "category": "Backend Engineering",
  "linkedin": "https://www.linkedin.com/in/tanmaysinghx/",
  "excerpt": "Unraveling the mechanics of the JVM—bytecode execution, class loading, GC behavior, JIT compilation, and the internal architecture of the String Constant Pool.",
  "content": [
    {
      "type": "paragraph",
      "text": "Many developers write Java code daily without truly understanding how the JVM converts `.java` files into highly optimized native code. A solid grasp of JVM internals is a force multiplier—enabling you to diagnose memory leaks, tune garbage collection, optimize startup time, and prevent production-grade failures."
    },
    {
      "type": "heading",
      "text": "1. The Compilation & Execution Flow"
    },
    {
      "type": "paragraph",
      "text": "Java source code is first compiled by `javac` into bytecode—platform-agnostic instructions stored in `.class` files. At runtime, the JVM dynamically loads classes, verifies bytecode safety, interprets instructions, and selectively JIT-compiles hot code paths into machine instructions."
    },
    {
      "type": "code",
      "language": "text",
      "code": "[ Source Code (.java) ]\n          ⬇ javac\n[ Bytecode (.class) ]  <-- Platform Independent\n          ⬇\n[ ClassLoader Subsystem ]\n   ├── Bootstrap Loader\n   ├── Extension Loader\n   └── Application Loader\n          ⬇\n[ Bytecode Verifier ]  <-- Ensures stack map frames, type safety, illegal ops\n          ⬇\n[ JVM Runtime Data Areas ]\n          ⬇\n[ Execution Engine ]\n   ├── Interpreter  (Executes line-by-line)\n   ├── C1 JIT (Client Compiler: Fast compilation, moderate optimization)\n   └── C2 JIT (Server Compiler: Aggressive optimization for hot methods)\n          ⬇\n[ Native Machine Code ]"
    },
    {
      "type": "paragraph",
      "text": "Modern JVMs (HotSpot) use *tiered compilation*, starting with interpretation for warm-up, compiling hotspots with C1, and using C2 for maximum throughput. Techniques like inlining, escape analysis, lock elision, intrinsics, and inline caching heavily accelerate execution."
    },
    {
      "type": "heading",
      "text": "2. JVM Memory Structure (Post Java 8)"
    },
    {
      "type": "paragraph",
      "text": "The JVM obtains memory from the OS and splits it into well-defined regions. Since Java 8, PermGen was removed and replaced by Metaspace, which automatically grows using native memory."
    },
    {
      "type": "code",
      "language": "bash",
      "code": "1. Heap Memory (Shared Across JVM)\n   - Young Generation\n       • Eden Space\n       • Survivor 0 (S0)\n       • Survivor 1 (S1)\n     -> Minor GC happens here.\n   - Old (Tenured) Generation\n     -> Major GC occurs here.\n   - Stores all Objects allocated via 'new'.\n\n2. Stack Memory (Per Thread)\n   - Each method call creates a Frame.\n   - Contains Local Variables, Operand Stack, Return Address.\n   - No objects; only references & primitives.\n\n3. Metaspace (Native Memory)\n   - Stores class metadata, method objects, vtables.\n   - Dynamically grows; tuned by MaxMetaspaceSize.\n\n4. Code Cache\n   - Stores JIT compiled native code.\n   - Split into Non-Profiled, Profiled, and Non-Method Code areas.\n\n5. PC Register\n   - Holds address of current instruction for each thread.\n\n6. Native Memory\n   - Used by JNI, Threads, DirectByteBuffers, GC structures."
    },
    {
      "type": "heading",
      "text": "3. The String Constant Pool (SCP) & Internals"
    },
    {
      "type": "paragraph",
      "text": "Strings get special treatment because they're heavily used. The SCP resides inside the Heap (not Metaspace) and holds interned strings. Literal strings are automatically placed in the pool; `new String()` bypasses it and creates redundant Heap objects."
    },
    {
      "type": "code",
      "language": "java",
      "code": "public class StringMagic {\n    public static void main(String[] args) {\n        String s1 = \"Java\";   // added to SCP\n        String s2 = \"Java\";   // refers to same SCP object\n\n        String s3 = new String(\"Java\");  // new Heap object\n\n        System.out.println(s1 == s2);        // true\n        System.out.println(s1 == s3);        // false\n        System.out.println(s1 == s3.intern()); // true\n    }\n}"
    },
    {
      "type": "paragraph",
      "text": "Interning is a memory optimization technique. It ensures all identical string values share the same reference, enabling faster equality comparison and reduced heap overhead. Under the hood, the SCP uses a hash-based structure backed by `StringTable`, which is periodically cleaned by GC."
    }
  ],
  "image": "https://cdn.bap-software.net/2024/01/03211643/How-is-AI-applied-to-Java-programming-e1704266486769.jpg"
}

]
